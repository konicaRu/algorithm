<<<<<<< HEAD
ну ни хрена себе
# algorithm
# konicaru.github.io
# competency_examples_not_nub
# Tkinter
# resume
resume
# resume
pictures_blog
=======
# Здесь находятся упражнения которые я решал на курсах по алгоритмам и структурам данных.  
![](https://raw.githubusercontent.com/konicaRu/data_structures_and_algorithms/master/pictures/algoritm200.jpg)
## Пример:
### Фильтр Блюма

Существует несколько подходов, позволяющих повысить эффективность работы хэш-системы. Один из них -- это фильтр Блюма, который не выдаёт точный результат, присутствует элемент в множестве или нет, а лишь вероятностный. При этом допускаются ложноположительные срабатывания (про несуществующий элемент сообщается, что он в наличии), но не ложноотрицательные (когда существующий элемент не находится). Вероятность ложного срабатывания находится в обратной зависимости от выделяемого под фильтр объёма памяти, что позволяет гибко его настраивать на конкретные условия эксплуатации.

1 Реализация фильтра Блюма

Реализуется фильтр Блюма на основе битового массива длиной m, который например из соображений эффективности, когда памяти достаточно, можно реализовать как массив логических значений. В таком случае мы получаем мгновенный O(1) доступ к каждому элементу, а в случае битовой реализации сложность завязывается на конкретный способ хранения битового массива. На практике часто ситуация противоположная: память для фильтра Блюма очень ограничена, но накладные расходы на работу с отдельными битами в машинных словах всё равно оправдывают экономию времени, когда основная система (кэш-системы, прокси-серверы, базы данных) будет выполнять подобную операцию в десятки раз дольше.

В фильтре Блюма реализуется семейство хэш-функций, отображающих входные значения в соответствующие индексы в пределах 1..m (или 0..m-1).

Исходно все m значений массива равны нулю. Когда в фильтр Блюма добавляется новый элемент, надо выставить единицы во всех позициях, которые выдадут все хэш-функции (подразумевается, что они это делают достаточно равномерно).
Каждая хэш-функция выдаёт только одну, единственную позицию, индекс, в массиве. Точнее, она в идеале выдаёт битовую маску, в которой в позиции этого индекса выставлена единичка.
Соответственно, проверка принадлежности элемента множеству требует, чтобы во всех позициях индексов, выдаваемых всеми хэш-функциями, были единицы. Если есть хотя бы один ноль, считаем, что элемент множеству не принадлежит.

В такой ситуации возможны ложные срабатывания "найден несуществующий", когда выставлены все единицы в позициях для конкретного элемента -- например, так скомбинировалась работа хэш-функций для других элементов. Но очевидно, что существующий элемент не может быть не найден, так как для него проставлены все единицы.

Зная фиксированное количество n значений на входе, можно подбирать такой размер m фильтра (битового массива), чтобы добиться подходящей вероятности ошибочного положительного срабатывания:

P = 0,6931 в степени (m / n)
А рекомендуемое количество хэш-функций такое:

k = 0,6931 * m / n
Обратите внимание, что чем больше элементов для анализа, тем меньше требуется хэш-функций, так как растёт вероятность того, что рассчитанные хэши будут значимо отличаться друг от друга.

Хэш-функции можно использовать достаточно простые, например версия для строки:
организуем цикл до длины строки, результат в этом цикле считаем как его версия с предыдущей итерации, умноженная на случайное число, к которой прибавляется код очередного символа, и берём результат тут же по модулю длины таблицы.

Хэш-функция возвращает число, которое удобно представить в виде битовой маски, и одной операцией выполнить наложение на битовый массив, если в языке поддерживается подходящий тип данных. Поэтому на практике используются более корректные математически в плане равномерности распределения хэш-функции, например одна из наиболее популярных -- MurmurHash (MUltiply and Rotate).

Плюсы фильтра Блюма: битовый массив можно делать произвольного размера, в том числе и совсем небольшим, ведь нам требуется просто быстро проверять наличие элемента, или наоборот, крайне крупным, ведь он хранится очень компактно. И сами хэш-функции можно хорошо реализовывать простыми алгоритмами. Очень важно так же, что операции над несколькими фильтрами можно выполнять побитовыми операциями сложения-умножения.

2 Модификации фильтров Блюма

Существуют гибридные версии фильтров, показывающие очень высокую степень надёжности, когда например в качестве ключей выступают строки. Строки разбиваются на последовательности из n элементов, для каждой последовательности вычисляется свой набор индексов, и результат комбинируется из результатов таких n-последовательностей.

Фильтр Блюма нередко применяется и в сферах, где используются словари, которые работают по похожим схемам, только с гарантированной "доставкой" результата. Это например оптимизированная модификация фильтра Блюма -- Bloomier filter, обобщающий оригинальную версию. Он хорошо работает при реализации словарей, для которых достаточно знать, принадлежит ли некоторый ключ словарю, пусть даже и небольшой вероятностью ошибки, а вот проверка отсутствия ключа в словаре не требуется. Bloomier filter подразумевает хранение и значения, ассоциированного с битовой картой, выданной для него хэш-функциями.

Эта концепция выглядит на первый взгляд немного парадоксальной, так как мы хотим реализовать словарь на типе данных, который и был придуман для того, чтобы избавиться от проблем, связанных со словарями. Основная идея такая: входные значения лежат в битовом диапазоне либо 0 или либо 1, и для каждого ключа строится набор фильтров Блюма (два, один для 0, другой для 1), которые по этому ключу выдают соответствующий ему корректный результат. Так как с помощью двух битов мы можем закодировать любые значения, то данный подход расширяется на битовые цепочки, и итерациями строятся своеобразные иерархии фильтров Блюма, которые хотя и потенциально могут экспоненциально расти, однако сходятся на практике достаточно быстро.

Здесь применяются так называемые статические функциональные значения, -- значения, вычисляемые функциями на лету. Сами значения ведь нигде не хранятся, а формируются функционально, операциями над множеством фильтров Блюма.

3 Задание
Реализуйте классический фильтр Блюма для строк на основе битового (не булевского) массива, выясните, имеется ли в выбранном языке программирования подходящий тип данных.

Для тестового примера можно использовать и обычное 32-разрядное целое число, то есть размер фильтра m=32. Примем количество значений для фильтра n=10, и получим примерное количество хэш-функций k=2.

Реализуйте две хэш-функции для строк по вышеописанной схеме.
В качестве результата первой итерации используйте ноль.
В качестве случайных чисел для первой функции используйте 17, для второй 223.
В качестве 10 тестовых строк используйте строки
"0123456789" "1234567890" ... "8901234567" "9012345678"   
## Пример реализации:
```
class BloomFilter:

    def __init__(self, f_len):
        self.filter_len = f_len
        self.slot = [0] * f_len  # создаём битовый массив длиной f_len ...

    def hash1(self, str1):
        res1 = 0  # 17
        for c in str1:
            code = ord(c)
            res1 = ((res1 * 17) + code) % self.filter_len
        return res1  # реализация ...

    def hash2(self, str1):  # 223    # ...
        res2 = 0  # 17
        for c in str1:
            code = ord(c)
            res2 = ((res2 * 223) + code) % self.filter_len
        return res2

    def add(self, str1):  # добавляем строку str1 в фильтр
        self.slot[self.hash1(str1)] = 1
        self.slot[self.hash2(str1)] = 1

    def is_value(self, str1):  # проверка, имеется ли строка str1 в фильтре
        if self.slot[self.hash1(str1)] == 1 and self.slot[self.hash2(str1)] == 1:
            return True
        else:
            return False
   ```         
>>>>>>> 7eea6d7f2e1868f1b5a6c5affaaf6835102e1657
